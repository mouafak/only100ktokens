// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";

contract TrumpsTriumphToken is ERC20("TRUMP'S TRIUMPH", "TRTR"), Ownable(address(msg.sender)) {
    using SafeERC20 for IERC20;
    using EnumerableSet for EnumerableSet.AddressSet;

    mapping(address => bool) public isFeeExempt;

    // Buy and Sell Fees
    uint256 public burnFeeBuy;
    uint256 public treasureBuy;
    uint256 public burnFeeSell;
    uint256 public treasureSell;

    // Fees receivers
    address private treasureWallet;

    EnumerableSet.AddressSet private _pairs;

    constructor(){
        uint256 _totalSupply = 100_000_000_000_000_000 * 1e18;
        isFeeExempt[msg.sender] = true;
        isFeeExempt[address(this)] = true;
        _mint(_msgSender(), _totalSupply);
    }

    function decimals() public view virtual override returns (uint8) {
        return 18;
    }

    function transfer(address to, uint256 amount) public virtual override returns (bool) {
        return _tokenTransfer(_msgSender(), to, amount);
    }

    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {
        address spender = _msgSender();
        _spendAllowance(sender, spender, amount);
        return _tokenTransfer(sender, recipient, amount);
    }

    function _tokenTransfer(address sender, address recipient, uint256 amount) internal returns (bool) {
        bool shouldTakeFee = (!isFeeExempt[sender] && !isFeeExempt[recipient]);
        uint256 side = 0;

        if (_pairs.contains(sender)) {
            side = 1; // Buy
        } else if (_pairs.contains(recipient)) {
            side = 2; // Sell
        } else {
            shouldTakeFee = false;
        }

        uint256 amountReceived = shouldTakeFee ? takeFee(sender, amount, side) : amount;
        _transfer(sender, recipient, amountReceived);

        return true;
    }

    function takeFee(address sender, uint256 amount, uint256 side) internal returns (uint256) {
        uint256 feeAmount = 0;
        if (side == 1) { // Buy
            feeAmount = (treasureBuy + burnFeeBuy) * amount / 10000;
            if (treasureBuy > 0) {
                _transfer(sender, treasureWallet, (amount * treasureBuy) / 10000);
            }
            if (burnFeeBuy > 0) {
                _burn(sender, (amount * burnFeeBuy) / 10000);
            }
        } else if (side == 2) { // Sell
            feeAmount = (treasureSell + burnFeeSell) * amount / 10000;
            if (treasureSell > 0) {
                _transfer(sender, treasureWallet, (amount * treasureSell) / 10000);
            }
            if (burnFeeSell > 0) {
                _burn(sender, (amount * burnFeeSell) / 10000);
            }
        }
        return amount - feeAmount;
    }

    function withdrawTRTR(address tokenAddress) external onlyOwner {
        IERC20(tokenAddress).safeTransfer(msg.sender, IERC20(tokenAddress).balanceOf(address(this)));
    }

    function withdrawEth() external onlyOwner {
        uint256 amountETH = address(this).balance;
        (bool success, ) = payable(_msgSender()).call{value: amountETH}(new bytes(0));
        require(success, "TRTR: ETH_TRANSFER_FAILED");
    }

    /*** ADMIN FUNCTIONS ***/
    function setBuyFees(uint256 _treasureFee, uint256 _burnFee) external onlyOwner {
        burnFeeBuy = _burnFee;
        treasureBuy = _treasureFee;
    }

    function setSellFees(uint256 _treasureFee, uint256 _burnFee) external onlyOwner {
        burnFeeSell = _burnFee;
        treasureSell = _treasureFee;
    }

    function setFeeReceivers(address _treasureWallet) external onlyOwner {
        treasureWallet = _treasureWallet;
    }

    function setIsFeeExempt(address holder, bool exempt) external onlyOwner {
        isFeeExempt[holder] = exempt;
    }

    function isPair(address account) public view returns (bool) {
        return _pairs.contains(account);
    }

    function addPair(address pair) public onlyOwner returns (bool) {
        require(pair != address(0), "TRTR: pair is the zero address");
        return _pairs.add(pair);
    }

    function delPair(address pair) public onlyOwner returns (bool) {
        require(pair != address(0), "TRTR: pair is the zero address");
        return _pairs.remove(pair);
    }

    receive() external payable {}
}
